<!-- Let's consider a scenario where we need to represent geometric points in a two-dimensional space. 
We want these points to be immutable and to have value semantics, meaning that two points with the same coordinates should be considered equal. 
We'll compare how implementing this with a record differs from using a regular class. -->


<!-- Regular class implementation: -->

public class Point {
    private final double x;
    private final double y;

    public Point(double x, double y) {
        this.x = x;
        this.y = y;
    }

    public double getX() {
        return x;
    }

    public double getY() {
        return y;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Point point = (Point) o;
        return Double.compare(point.x, x) == 0 && Double.compare(point.y, y) == 0;
    }

    @Override
    public int hashCode() {
        return Objects.hash(x, y);
    }

    @Override
    public String toString() {
        return "(" + x + ", " + y + ")";
    }
}


<!-- Record implementation: -->

record Point(double x, double y) {}


<!-- In both cases, we achieve the same functionality: a representation of a point in a two-dimensional space. However, with the record version:
• We eliminate a significant amount of boilerplate code. 
  There's no need to write constructor, accessor methods (getX() and getY()), equals(), hashCode(), or toString() methods. All of these are automatically generated by the compiler.
• Records inherently provide immutability. Once a record instance is created, its state cannot be changed, which ensures safety in concurrent environments.
• Records provide value semantics by default. Two Point records with the same x and y coordinates will be considered equal, simplifying comparison logic.
• Records promote readability and maintainability by reducing the amount of code that developers need to write and maintain -->